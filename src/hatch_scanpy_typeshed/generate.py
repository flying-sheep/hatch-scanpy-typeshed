"""Creates Python code from signatures."""

from __future__ import annotations

from inspect import Parameter, signature
from types import FunctionType
from typing import TYPE_CHECKING

from .transform import transform_signature

if TYPE_CHECKING:
    from collections.abc import Generator, Sequence
    from types import ModuleType


TEMPLATE_MOD = """\
# This file is autogenerated by hatch-scanpy-typeshed
from __future__ import annotations

{imports}

{functions}
"""

TEMPLATE_FUNC = """\
@overload
def {name}(
    {parameters}
) -> {return_annotation}: ...\
"""


def generate_overloads(mod: ModuleType) -> str:
    """Generate overloads for a module."""
    names: Sequence[str] | None
    if (names := getattr(mod, "__all__", None)) is None:
        msg = f"Module {mod.__name__} has no __all__ attribute."
        raise ValueError(msg)
    func_strs: list[str] = []
    for name in names:
        function = getattr(mod, name)
        if not isinstance(function, FunctionType):
            continue
        sig_orig = signature(function)
        sigs = list(transform_signature(sig_orig))
        if len(sigs) == 1:
            continue  # We didnâ€™t add anything of value
            # TODO(flying-sheep): maybe we still need to emit them

        func_strs.extend(_format_func(sig, name) for sig in sigs)

    imports = "import typing\nfrom anndata import AnnData"
    return TEMPLATE_MOD.format(imports=imports, functions="\n\n".join(func_strs))


def _format_func(sig: signature, name: str) -> str:
    """Format a function signature."""
    return TEMPLATE_FUNC.format(
        name=name,
        parameters="\n    ".join(_format_params(sig.parameters.values())),
        return_annotation=sig.return_annotation,
    )


def _format_params(params: Sequence[Parameter]) -> Generator[str, None, None]:
    if pos_only := [_format_param(p) for p in params if p.kind is Parameter.POSITIONAL_ONLY]:
        yield from pos_only
        yield "/,"
    yield from (_format_param(p) for p in params if p.kind is Parameter.POSITIONAL_OR_KEYWORD)
    if kw_only := [_format_param(p) for p in params if p.kind is Parameter.KEYWORD_ONLY]:
        yield "*,"
        yield from kw_only


def _format_param(param: Parameter) -> str:
    fmt = f"{param.name}: {param.annotation}"
    if param.default is not Parameter.empty:
        fmt += f" = {param.default!r}"
    return f"{fmt},"
